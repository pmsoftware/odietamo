package dbfit.fixture;

import java.sql.PreparedStatement;
// start bupa adds
import java.sql.CallableStatement;
// end bupa adds
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Map;

import dbfit.environment.DbEnvironmentFactory;
import dbfit.environment.DBEnvironment;
import dbfit.util.*;
import fit.Binding;
import fit.Parse;

public class Insert extends fit.Fixture {
	private DBEnvironment environment;
	private PreparedStatement statement;
	private String tableName;
	private DbParameterAccessor[] accessors;
	private Binding[] columnBindings;
    public Insert()
    {
    	System.out.println("Insert()");
        this.environment = DbEnvironmentFactory.getDefaultEnvironment();
    }
    public Insert(DBEnvironment dbEnvironment)
    {
    	System.out.println("Insert(DBEnvironment)");
        this.environment=dbEnvironment;
    }
	public Insert(DBEnvironment dbEnvironment, String tableName) {
		System.out.println("Insert(DBEnvironment, String)");
		this.tableName= tableName;
		this.environment = dbEnvironment;		
	}
	public PreparedStatement BuildInsertCommand(String tableName, DbParameterAccessor[] accessors) throws SQLException {
		System.out.println("Insert: BuildInsertCommand: Calling environment.buildInsertCommand for tableName: "+tableName); 
		String ins=environment.buildInsertCommand(tableName, accessors);
		System.out.println("Insert: BuildInsertCommand: got back ins: "+ins);
		System.out.println("Insert: BuildInsertCommand: supportsOuputOnInsert(): "+environment.supportsOuputOnInsert());
		PreparedStatement cs=
				(environment.supportsOuputOnInsert())?
							environment.getConnection().prepareCall(ins):
							environment.getConnection().prepareStatement(ins,Statement.RETURN_GENERATED_KEYS);
		System.out.println("Insert: BuildInsertCommand: cs instanceof CallableStatement?: "+(cs instanceof CallableStatement));
		for (int i=0; i<accessors.length; i++){
			accessors[i].bindTo(this, cs, i+1);
		}
		return cs;
	}
	public void doRows(Parse rows) {
		System.out.println("Insert: doRows");
		// if table not defined as parameter, read from fixture argument; if still not defined, read from first row
        if ((tableName==null || tableName.trim().length()==0) && args.length > 0)
        {
            tableName = args[0];
        }
		else if (tableName == null) {
				tableName=rows.parts.text();
				rows = rows.more;
		}
        try {
			initParameters(rows.parts);//init parameters from the first row			
	        statement= BuildInsertCommand(tableName, accessors);
	        Parse row = rows;
			while ((row = row.more) != null) {				
				runRow(row);
			}			
		//rows.Parts.Last.More=new Parse("td",Gray("Generated Query: " + command.CommandText),null,null);
        }
        catch (Throwable e){
        	e.printStackTrace();
        	exception(rows.parts,e);
        }
      }
	
	private void initParameters(Parse headerCells) throws SQLException {
		System.out.println("Insert: initParameters");
		Map<String, DbParameterAccessor> allParams=
			environment.getAllColumns(tableName);
		if (allParams.isEmpty()){
			throw new SQLException("Cannot retrieve list of columns for "+tableName+" - check spelling and access rights");
		}
		accessors = new DbParameterAccessor[headerCells.size()];		
		columnBindings=new Binding[headerCells.size()];
		for (int i = 0; headerCells != null; i++, headerCells = headerCells.more) {
			String name=headerCells.text();
			String paramName= NameNormaliser.normaliseName(name);
			accessors[i] = allParams.get(paramName);			
			if (accessors[i]==null){
				wrong(headerCells);
				throw new SQLException("Cannot find column "+paramName);
			}
			if (headerCells.text().endsWith("?")){
				// if output parameters on insert are supported by the db environment, just switch
				// direction to output
				if (environment.supportsOuputOnInsert()){
						accessors[i].setDirection(DbParameterAccessor.OUTPUT);	
				}
				// else, use the autokey accessor
				else{
					accessors[i]=new DbAutoGeneratedKeyAccessor(accessors[i]);
				}
				columnBindings[i]=new SymbolAccessQueryBinding();
			}
			else
				columnBindings[i]=new SymbolAccessSetBinding();
        	columnBindings[i].adapter=accessors[i];
		}
	}
	private void runRow(Parse row)  throws Throwable{
		System.out.println("Insert: rowRow");
		statement.clearParameters();
		Parse cell = row.parts;
		//first set input params
		for(int column=0; column<accessors.length; column++,	cell = cell.more){
			System.out.println("Insert: runRow: accessors["+column+"]");
			if (accessors[column].getDirection()==DbParameterAccessor.INPUT) {
				System.out.println("Insert: runRow: accessors["+column+"].getDirection()==INPUT");
				columnBindings[column].doCell(this, cell);
			}
		}
		try { // Bupa
		statement.execute();
		} catch (Exception e){ // Bupa
			System.out.println("Insert: runRow: caught exception with message: "+e.getMessage()); // Bupa
			Throwable t = new Throwable(); // Bupa
			throw t; // Bupa
		} // Bupa
		
		cell = row.parts;
		
		//next evaluate output params
		for(int column=0; column<accessors.length; column++, cell = cell.more){
			System.out.println("Insert: runRow(evaluate output): column: [column["+column+"]");
			if (accessors[column].getDirection()==DbParameterAccessor.OUTPUT||
					accessors[column].getDirection()==DbParameterAccessor.RETURN_VALUE) {
				System.out.println("Insert: runRow(evaluate output): column["+column+"] -- binding");
				columnBindings[column].doCell(this, cell);
			}
		}							
	}
}
